"""Tools for running the AOC problem files generated by aoctools"""

import importlib
import re
import sys

from pathlib import Path
from typing import Optional

import aoctools.common as aoc_common


def _target_method(day: int, part: int):
    target_module = f"aoc.d{day:02d}"
    module = importlib.import_module(target_module)

    try:
        return getattr(module, f"p_{part}")
    except AttributeError:
        print(f"__init__.py for module {target_module} must include p_{part}")
        sys.exit(1)


def run(root_path: str, day: int, part: int, debug: bool):
    """
    Runs an AOC problem

    Parameters
    ----------
    root_path
        The path of the root AOC problem directory
    day
        The problem day, e.g., 1, 2, ... 25
    part:
        The problem part, i.e., 1 or 2
    debug:
        Print debug info?
    """

    target_method = _target_method(day, part)
    data_path = Path(root_path, 'data', f"d{day:02d}", 'input.txt')

    with open(data_path, 'r', encoding='utf8') as input_file:
        res = target_method(input_file, debug=debug)
        if res is not None:
            print(f"solution to day {day}, part {part}: {res}")
        else:
            print('no solution found')
            sys.exit(1)

# pylint: disable=too-many-locals


def run_example(root_path: str, day: int, debug: bool,
                example: Optional[int] = None):
    """
    Runs one or more AOC examples for a given day

    Parameters
    ----------
    root_path
        The path of the root AOC problem directory
    day
        The problem day, e.g., 1, 2, ... 25
    debug:
        Print debug info?
    example:
        The specific example to run; by default, all examples are run
    """

    if example is not None:
        path = Path(root_path).joinpath('data', f"d{day:02d}",
                                        f"example_{example:02d}.txt")
        if not path.exists():
            raise Exception(f"no example {example} for day {day}")
        paths = [(example, path)]
    else:
        paths = aoc_common.get_examples_sorted(root_path, day)

    p_1_method = _target_method(day, 1)
    p_2_method = _target_method(day, 2)

    part_re = re.compile(r"^part: (1|2)$")
    expected_re = re.compile(r"^expected: (.+)$")

    for (idx, example_path) in paths:
        with open(example_path, 'r', encoding='utf8') as input_file:
            part_match = part_re.match(input_file.readline())
            if not part_match:
                raise Exception("example files must start with 'part: (1|2)'")
            part_number = int(part_match.groups()[0])

            expected_math = expected_re.match(input_file.readline())
            if not expected_math:
                raise Exception("example files must have 'expected: (.+)' "
                                'as their second line')
            expected = expected_math.groups()[0]

            if not input_file.readline() in ['\n', '\r\n', '\r']:
                raise Exception('expected a blank line between example '
                                'frontmatter and example text')

            target_method = p_1_method if part_number == 1 else p_2_method
            res = target_method(input_file, debug=debug)
            if res is not None:
                if str(res) == expected:
                    print(f"solution to example {idx}: {res} (expected)")
                else:
                    print(f"solution to example {idx}: {res} does not match "
                          f"the expected value of {expected}")
            else:
                print(f"no solution given to example {idx}")
                sys.exit(1)
